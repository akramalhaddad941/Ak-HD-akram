# نظام إدارة الأخطاء المحكم (Robust Error Management System)

نظام إدارة الأخطاء المحكم هو مكون أساسي في `نظام الدعم الشامل`، ومهمته الأساسية هي التعامل مع حالات الفشل والأخطاء التي قد تحدث في أي مرحلة من مراحل عملية ترجمة الفيديو. يهدف هذا النظام إلى تقليل تأثير الأخطاء على تجربة المستخدم وضمان استمرارية الخدمة.

## الغرض والأهداف

*   **اكتشاف الأخطاء**: رصد وتحديد الأخطاء في الوقت الفعلي عبر جميع خدمات النظام.
*   **تصنيف الأخطاء**: تصنيف الأخطاء حسب شدتها ونوعها (مثل: خطأ مؤقت، خطأ دائم، خطأ في البيانات، خطأ في الاتصال).
*   **الاستعادة التلقائية**: تطبيق استراتيجيات استرداد تلقائية لتمكين النظام من التعافي من الأخطاء المؤقتة دون تدخل بشري.
*   **التسجيل والتحليل**: تسجيل جميع الأخطاء وتحليلها لتحديد الأسباب الجذرية وتحسين موثوقية النظام على المدى الطويل.

## استراتيجيات إدارة الأخطاء

1.  **المحاولة المتكررة مع التراجع الأسي (Exponential Backoff and Retry)**:
    *   عند حدوث خطأ مؤقت (مثل فشل اتصال الشبكة بمحرك ترجمة خارجي)، لا يتم إيقاف العملية فورًا.
    *   بدلاً من ذلك، يتم إعادة محاولة العملية بعد فترة زمنية تزداد بشكل أسي مع كل فشل (مثل 1 ثانية، 2 ثانية، 4 ثواني)، حتى الوصول إلى الحد الأقصى لعدد المحاولات.

2.  **قاطع الدائرة (Circuit Breaker Pattern)**:
    *   إذا استمر محرك ترجمة أو خدمة معينة في الفشل، يقوم النظام بفتح قاطع الدائرة، مما يمنع إرسال المزيد من الطلبات إلى تلك الخدمة لفترة محددة.
    *   هذا يحمي الخدمة الفاشلة من الضغط الإضافي ويتيح لها وقتًا للتعافي، ويمنع النظام من إضاعة الموارد على طلبات محكوم عليها بالفشل.

3.  **الاحتياطي (Fallback Mechanism)**:
    *   عند فشل محرك ترجمة أساسي أو خبير متخصص، يتم التبديل تلقائيًا إلى محرك احتياطي عام (مثل Google Translate) لضمان إرجاع نتيجة ترجمة للمستخدم، حتى لو كانت بجودة أقل.
    *   يتم تسجيل استخدام الاحتياطي كـ "تنبيه جودة" للمراجعة.

4.  **عزل الأخطاء (Error Isolation)**:
    *   تصميم النظام بحيث لا يؤدي فشل مكون واحد إلى تعطل النظام بأكمله.
    *   على سبيل المثال، إذا فشل `نظام STT المتقدم`، يجب أن يتمكن النظام من معالجة الترجمة باستخدام نص مدخل من المستخدم.

## التنفيذ التقني (مثال)

```typescript
// src/services/errorManagement.ts
import { EngineControlConfiguration } from '../interfaces/configuration';

export class ErrorManagementSystem {
  private maxRetries = 3;
  private circuitBreakerState: Map<string, { isOpen: boolean, openUntil: number }> = new Map();

  async executeWithRetry<T>(
    operation: () => Promise<T>,
    serviceName: string,
    fallbackOperation?: () => Promise<T>
  ): Promise<T> {
    // 1. Check Circuit Breaker
    const breaker = this.circuitBreakerState.get(serviceName);
    if (breaker && breaker.isOpen && breaker.openUntil > Date.now()) {
      console.warn(`Circuit breaker is open for ${serviceName}. Falling back.`);
      if (fallbackOperation) return fallbackOperation();
      throw new Error(`Service ${serviceName} is unavailable.`);
    }

    // 2. Retry Logic
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        const result = await operation();
        // If successful, close circuit breaker if it was open
        this.closeCircuitBreaker(serviceName);
        return result;
      } catch (error) {
        console.error(`Attempt ${attempt + 1} failed for ${serviceName}:`, error);
        if (attempt === this.maxRetries - 1) {
          // 3. Open Circuit Breaker on final failure
          this.openCircuitBreaker(serviceName);
          if (fallbackOperation) {
            console.log(`Final attempt failed. Using fallback for ${serviceName}.`);
            return fallbackOperation();
          }
          throw new Error(`Operation failed after ${this.maxRetries} attempts.`);
        }
        // Exponential Backoff
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    // Should not be reached
    throw new Error('Execution failed unexpectedly.');
  }

  private openCircuitBreaker(serviceName: string) {
    const openDuration = 60 * 1000; // 60 seconds
    this.circuitBreakerState.set(serviceName, {
      isOpen: true,
      openUntil: Date.now() + openDuration,
    });
    console.error(`Circuit Breaker opened for ${serviceName} until ${new Date(Date.now() + openDuration).toLocaleTimeString()}`);
  }

  private closeCircuitBreaker(serviceName: string) {
    if (this.circuitBreakerState.get(serviceName)?.isOpen) {
      this.circuitBreakerState.set(serviceName, { isOpen: false, openUntil: 0 });
      console.log(`Circuit Breaker closed for ${serviceName}.`);
    }
  }
}

export const errorManagementSystem = new ErrorManagementSystem();
```

يضمن نظام إدارة الأخطاء المحكم أن النظام يمكنه التعامل مع حالات الفشل بذكاء ومرونة، مما يعزز بشكل كبير من موثوقية الخدمة واستقرارها.
